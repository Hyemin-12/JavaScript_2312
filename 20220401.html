<script>
	//렉시컬 환경 이어서

	// function makeObjectwithClosureMethod(value){
	// 	let x = 100;
	// 	let obj = {
	// 		method(arg){ //이 함수(메소드 형태지만 함수)는 바깥의 make어쩌고 함수를 기억함
	// 			console.log(value, x, arg); //바깥의 렉시컬 환경도 기억하기 때문에 value, x를 참조 가능
	// 		}//보통은 렉시컬 환경이 제거되지만 함수 안에서 함수가 리턴될 때는 렉시컬 환경을 기억함 (+ 함수=>클로저)
	// 	};
	// 	return obj;
	// }
	// let o = makeObjectwithClosureMethod("Hello");
	// o.method("World");

	// function makeCounter() {
	// let count = 0;
	// // 또한, 함수는 자신이 정의된 시점에 존재하는 바깥 환경을 기억함
	// 	return function() {
	// 		// 반환된 이후에도 호출되어 외부 영역의 값(count)에 접근 가능 (클로저)
	// 		return count++;
	// 	};
	// }

	// let c1 = makeCounter();

	// alert( c1() ); // 0 (함수 호출 과정에서 함수가 정의되던 시점의 외부 환경 값(count)
	// alert( c1() ); // 1

	// let c2 = makeCounter(); //함수를 호출할 때마다 새로운 렉시켤 환경이 생성됨(독립적)

	// //0과 1이 나옴(2와 3아님)
	// alert( c2() );  
	// alert( c2() ); 

	// let count = 0; //count가 바깥에 있으므로 전역 실행이니까 렉시컬 환경을 공유함(0, 1, 2, 3 출력)
	// function makeCounter() {
	// 	return function() {
	// 		return count++;
	// 	};
	// }

	// let c1 = makeCounter();

	// alert( c1() ); // 0 
	// alert( c1() ); // 1

	// let c2 = makeCounter(); 

	// alert( c2() ); // 2
	// alert( c2() ); // 2

	// function makeCounter() { 
	// 	let count = 0; 
	// 	return [
	// 		function() {
	// 			return count++;
	// 		}, 
	// 		function(){ //만들어질 때의 환경을 기억하므로 똑같이 (0, 1, 2, 3)이 나옴 
	//		//그 기억하고 있는 곳을 [[Environment]]라고 부른다
	// 			return count++; //렉시컬 환경이 같으면 공유하는 거(전역 환경은 모두 공유) 
	// 		}
	// 	];
	// }

	// let [c1, c2] = makeCounter();

	// alert( c1() ); // 0
	// alert( c1() ); // 1
	// alert( c2() ); // 2
	// alert( c2() ); // 3

	//전역 렉시컬 환경의 바깥(외부 환경)에는 NULL이 저장되어있음(아무것도 없으니까)
	//렉시컬 환경 안에는 외부 렉시컬 환경에 접근할 수 있는 참조가 저장되어있다(환경 레코드)

	// //전역 실행 컨텍스트에 전역 렉시컬 환경이 있고 그 안에 환경레코드가 있음
	// let a = 100; //실행하기 전에는 환경레코드엔 uninitialized로 저장되어있음(var는 undefined)
	// a = 200;     
	// //실행하면서 환경레코드 안의 값도 100, 200으로 바뀜(선언을 하지 않고 초기화만 했을 경우 let은 undefined로 바뀜)

	// let phrase = "Hello";

	// function say(name){
	// //환경레코드에서 내부 렉시컬 환경에서 값을 못찾으면 외부에서 찾음(전역 객체까지 찾고 없으면 에러 발생)
	// //이것을 스코프 체인이라고 함(내부에 없는걸 외부에서 찾고 찾고 찾는 것)
	// 	alert( '${phrase}, ${name}' ); //외부 렉시컬 환경에서 찾은 phrase를 참조
	// }	
	// say("John");

	// function oops() {
	// 	// 아마도 var 혹은 let 키워드를 실수로 인해서 생략한 코드
	// 	notExist = "?"; //원래는 에러가 나야하지만 비엄격모드에서는 냅다 전역 변수(전역 개체에다)를 만들어버림
	// 					//엄격모드에서는 에러가 남(가급적 엄격모드를 사용하는 것이 좋음)
	// }
	// oops();
	// // 실수로 인해서 전역 변수가 생김
	// alert(window.notExist);

	// //렉시컬 환경 : z => y => x => null
	// let x = 100;
	// function func1(y) {
	// 	function func2(z) {
	//		// alert 함수를 호출하는 시점에서 렉시컬 환경을 그려보기
	//		alert(`${x},${y},${z}`);
	//	}	
	//	func2(300);
	// }
	// func1(200);

	// //렉시컬 환경이 윈도우 객체(전역 렉시컬 환경인 alert)보다 우선 순위가 더 높음
	// function alert(s){ 
	// 	console.log(s);
	// }
	// alert("hi"); //이러면 그 출력하는 걔가 안뜨고 걍 콘솔창에 alert 함수를 호출한 게 뜸

	//클로저 => 함수 + 함수가 기억하고 있는(참조하는) 렉시컬 환경
	//자바스크립트에서는 모든 함수가 클로저 함수

	// //Q1
	// let a = 100;
	// function func1() {
	// 	let b = 200;
	// 	function func2() {
	// 		let c = 300; //c는 공유가 안됨(독립적으로 증가함), 함수를 호출할 때마다 새로 c값을 가짐 301, 302...
	// 		return function(amount = 1) {
	// 			a += amount; b += amount; c += amount;
	// 			console.log(a, b, c);
	// 		}
	// 	}
	// 	return func2();
	// }
	// let f1 = func1();
	// f1();
	// f1();
	// f1();
	// let f2 = func1();
	// f2(2);
	// f2(3);
	// f2(4);

	// //Q2
	// let a = 100;
	// function func1() {
	// 	let b = 200;
	// 	function func2() {
	// 		return function() {
	// 			let c = 300; //c는 공유가 안됨(독립적으로 증가함), return 안에 찍혀있으므로 맨날 301이 출력됨
	// 			a++; b++; c++;
	// 			console.log(a, b, c);
	// 		}
	// 	}
	// 	return [func2(), func2()]; //[]은 안의 함수들이 서로 값을 공유함
	// }
	// let fArr = func1();
	// fArr[0]();
	// fArr[1]();

	//call, apply, bund는 평소엔 머..쓸모 없는데 데코레이트?어쩌고 그거 할 때는 중요함
	//call => this에 인자값(가변 인자)을 줘서 부를 때마다 값을 바꿀 수 있다
	function printThis() {
		console.log(this);
	}

	let person = { name: "John", age: 20 };
	let dog = { name: "Sam", age: 5 };

	printThis.call(person); // { name: "John", age: 20 }
	printThis.call(dog); // { name: "Sam", age: 5 }

	//파라미터가 있는 함수는 호출할 때(this에 넣을 값, 파라미터)순으로 호출
	function printName(prefix, times=1) { 
		console.log(this);
		for(let i=0;i<times;i++) {
			console.log(prefix, this.name);
		}
	}

	printName.call(person, "Hello", 2);
	printName.call(dog, "Good");

	//apply는 this값을 바꿔주는 건 call과 같지만 얘는 배열로 인자값을 준다
	function printThis() {
		console.log(this);
	}
	let person = { name: "John", age: 20 };
	let dog = { name: "Sam", age: 5 };

	printThis.apply(person); // { name: "John", age: 20 }
	printThis.apply(dog); // { name: "Sam", age: 5 }

	//파라미터가 있을 때는 파라미터도 배열로 넘겨야 함
	function printName(prefix, times=1) {
		console.log(this);
		for(let i=0;i<times;i++) {
			console.log(prefix, this.name);
		}
	}
	printName.apply(person, ["Hello", 2]);
	printName.apply(dog, ["Good"]);
	// 굳이 배열을 전달하면서 call 메서드를 써야 한다면, 전개 연산자(...) 써서 배열을 가변 인자로 바꿔 전달해주기
	printName.call(person, ...["Hello", 2])
	//call, apply => 내가 직접 디스값을 정해줌

	//bind => 내가 this로 바인딩(구속)한 함수를 재참조(반환)하고 싶음(원래는 객체 외부의 다른 곳에서 호출되면 this 사라짐)
	//호출 하는 거 아님!!
	//특정 파라미터 값을 적용 시킬 때도 쓰임(부분 적용)
	//바인드는 한번 하면 안바뀜
	let user = {
		firstName: "John",
		sayHi() { alert(`Hello, ${this.firstName}!`); }
	};
	// "Hello, John!" 출력
	user.sayHi();
	// "Hello, undefined!" 출력
	setTimeout(user.sayHi, 1000);
</script>