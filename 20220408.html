<script>
	/*
	//부분 적용(쓸 일 잘 없음)
	//바인드를 이용해 특정 파라미터 값을 적용 시키는 것
	//(함수_심화학습_3 참조)

	//화살표 함수
	//화살표 함수는 this가 없어서 함수를 호출하면 외부 환경에서 this 값을 가져옴
	//화살표 함수로 생성자 만들지 마(뭐하러..?)this랑 new 같이 못 씀
	let group = {
		title: "1모둠",
		students: ["보라", "호진", "지민"],
		showList() {
			//showList안의 this는 group
			//화살표 함수 안의 this는 외부 환경인 showList에서 가져온 group
			this.students.forEach(student => alert(this.title + ': ' + student));
		}
	};
	group.showList();

	let group = {
		title: "1모둠",
		students: ["보라", "호진", "지민"],
		showList() {
		this.students.forEach(function(student) {
			//화살표 함수가 아니어서 => undefined
			// TypeError: Cannot read property 'title' of undefined
			alert(this.title + ': ' + student);
			});
		}
	};
	group.showList();

	let group = {
		title: "1모둠",
		students: ["보라", "호진", "지민"],
		showList() {
			let self = this;
			// 클로저 특성(자신이 만들어진 환경을 기억)을 활용하여 해결(별로...비권장 하지마 걍 화살표 함수 쓰기)
			this.students.forEach(function(student) {
				alert(self.title + ': ' + student);
			});
		}
	};
	group.showList();

	//화살표 함수엔 arguments가 없음
	//(함수_심화학습_3 참조)

	//던더(Dunder) 게터
	//[[]] 대괄호 두개 => 숨겨진 객체
	//숨겨진 [[Prototype]] 객체에 접근 하는 방법
	//1.__proto__게터(던더게터)를 통해 접근 가능
	//__proto__ != [[Prototype]](__proto__은 [[prototype]]객체에 접근하기 위한 하나의 관문)
	//2.Object.getPrototypeOf를 접근 가능(이게 최신 방법, 이거 쓰기)
	//__proto__ === Object.getPrototypeOf
	//(프로토타입과_프로토타입_상속 참조)
	//화살표 함수는 프로토타입도 없음
	//[[prototype]]은 모든 객체에 있고, prototype객체는 함수에만 있다

	//함수 선언식이든 표현식이든 정의하면 모두 prototype이라는 객체를 가짐(__proto__ 아님!)
	//prototype은 constructor라는 속성을 가지고 있는데 그 속성은 자기 자신을 가리키는 함수가 저장됨
	function hello() {};
	let world = function() {};
	console.log(hello.prototype); // { constructor: hello } <= 자기 자신인 hello를 가리킴
	console.log(hello.prototype.constructor === hello); // true
	console.log(world.prototype); // { constructor: world } <= 자기 자신인 world를 가리킴
	console.log(world.prototype.constructor === world); // true

	//new 키워드와 함께 함수를 호출하면 this에 새 객체를 할당 하고 자동으로 this를 반환함
	//또한, 해당 객체를 생성할 때 this.__proto__에 자동으로 생성자 함수의 prototype을 대입
	//객체에 원하는 값이 없으면 이제 저기 User.prototype에서 찾음
	function User(name){
		//this = {}
		//this.__proto__ = User.prototype //{ constructor: User}
		this.name = name;
		//return this;
	}

	function Animal(name, age) {
		// new 키워드와 함께 생성자 함수가 호출될 경우, 마치 아래 코드와 같은 작업을 자동으로	해주게 됨
		// Object.setPrototypeOf(this, Animal.prototype);
		this.name = name;
		this.age = age;
	};
	let sam = new Animal("Sam", 2);
	console.log(sam.__proto__); // { constructor: Animal }
	console.log(sam.__proto__ === Animal.prototype); // true
	console.log(sam.__proto__.constructor === Animal); // true

	//(프로토타입과_프로토타입_상속 참조)
	//prototype에 공통메소드를 정의해도 메소드 내부의 this값은 점 앞 객체를 가리킴

	//Object.Create 메소드

	//**상속**
	// Shape - 부모 클래스(superclass)
	function Shape(x, y) {
		this.x = x;
		this.y = y;
	}
	// 부모 클래스의 메서드를 prototype객체에 정의
	Shape.prototype.move = function(x, y) {
		console.log(`Shape moved from ${this.x},${this.y} to ${x},${y}`);
		this.x += x;
		this.y += y;
	}
	// Rectangle - 자식 클래스(subclass)
	function Rectangle(x, y, w, h) {
		//call : this값 -> 가변인자
		// 부모 생성자 함수 호출(자바로 비유하자면)
		// 자바의 super와 비슷한 기능이라고 생각하면 됨(new를 호출 안함! -> shape에서는 this 새 객체를 만들지 않음)
		Shape.call(this, x, y); //this에는 빈 객체가 담겨져 있음, shape에서 x, y를 this에 대입
		this.w = w; 
		this.h = h;
	}
	// Object.create 메서드를 호출하여 Shape.prototype을 프로토타입 객체로 사용하는 비어있는 객체를 생성 후 Rectangle 생성자 함수의 prototype 속성 지정
	//Shape.prototype을 찾아갈 수 있도록 함
	// Rectangle.prototype에 대입될 객체의 모습 => { __proto__: Shape.prototype }
	Rectangle.prototype = Object.create(Shape.prototype);

	// Rectangle.prototype 객체의 constructor가 Object.create로 인하여 찾을 수 없게 됐으므로 다시 복원**
	Rectangle.prototype.constructor = Rectangle;

	// Rectangle 생성자 함수를 통해서 생성된 객체가 사용할 공통 메서드 정의
	Rectangle.prototype.size = function() {
		return this.w * this.h;
	}
	let rect = new Rectangle(0, 0, 20, 10);
	// Shape.prototype 접근을 통해서 move 메서드를 호출
	console.log(rect.move(5, 5));
	console.log(rect.size());

	//Q
	//부모 클래스 Shape
	function Shape(x, y) {
		this.x = x;
		this.y = y;
	}
	// 부모 클래스의 메서드 정의
	Shape.prototype.move = function(x, y) {
		console.log(`Shape moved from ${this.x},${this.y} to ${x},${y}`);
		this.x += x;
		this.y += y;
	}
	
	//자식 클래스 Circle
	function Circle(x, y, r){
		//Shape.call => 생성자 역할(but new연산자 없음, 자바의 super와 비슷)
		Shape.call(this, x, y);
		this.r = r;
	}

	//Object.create사용 => { __proto__: Shape.prototype }
	Circle.prototype = Object.create(Shape.prototype);

	//복원
	Circle.prototype.constructor = Circle;

	//메서드 정의
	Circle.prototype.area = function(){
		return Math.PI * (this.r ** 2);
	}

	//생성자 함수
	let c = new Circle(0, 0, 5);
	c.move(5, 5);
	console.log(c.area(5));
	*/

	//let o = {};
	// 위의 코드와 동일한 작업 수행
	let o = new Object();
	// Object 생성자 함수를 이용해서 생성한 객체이므로 당연히 o의 __proto__는 Object.prototype을 가리킴
	// o.__proto__ === Object.prototype

	// toString과 같은 정의되지 않은 메서드를 쓸 수 있는 것도 프로토타입 체인을 거슬러 올라가 Object.prototype에 정의된 메서드를 호출하기 때문이다
	console.log(o.toString());

	// Object.prototype이 최상위 프로토타입 객체이므로 null이 나온다
	console.log(o.__proto__.__proto__); // null
	console.log(Object.prototype.__proto__); // null

	//생성자 함수의 prototype의 속성 constructor는 자기 자신임
	//생성자 함수를 만들면 걔는 무조건 Object.prototype을 상속 받음
	// (중요) 바꾸어 말하자면 어떤 생성자 함수를 통해서 만들어진 객체건 프로토타입 체인을 거슬러 올라가면 가장 마지막으로 Object.prototype 객체에 접근할 수 있다는 말이 됨


</script>